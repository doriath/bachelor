\chapter{Theory}

%Rozdział teoretyczny --- przegląd literatury naświetlający stan wiedzy na dany temat. 
%
%Przegląd literatury naświetlający stan wiedzy na dany temat obejmuje rozdziały pisane na podstawie
%literatury, której wykaz zamieszczany jest w części pracy pt.~\emph{Literatura} (lub inaczej \emph{Bibliografia},
%\emph{Piśmiennictwo}). W tekście pracy muszą wystąpić odwołania do wszystkich pozycji zamieszczonych w
%wykazie literatury. \textbf{Nie należy odnośników do literatury umieszczać w stopce strony.} Student jest
%bezwzględnie zobowiązany do wskazywania źródeł pochodzenia informacji przedstawianych w pracy,
%dotyczy to również rysunków, tabel, fragmentów kodu źródłowego programów itd. Należy także podać
%adresy stron internetowych w przypadku źródeł pochodzących z Internetu.

In this chapter the background for Paxos algorithm is presented.



\section{Definitions}

In order to prevent misunderstandings and to clarify the subject of the thesis we open it with definitions of
basic % TODO lepszy odpwoednik 
terms we use.


\paragraph{Consensus}
is a problem in distributed computing that encapsulates the task of group agreement in the presence of faults.

\begin{description}
    \item[Validity] any value decided is a value proposed by some process,
    \item[Agreement] no two processes decide differently,
    \item[Termination] every correct process eventually decides,
    \item[Integrity] no process decides twice
\end{description}

\paragraph{State machine}
is any program, algorithm or protocol that can be described by it's state and that can transit to other state only by receiving a command.
There are no restrictions how the state may change.

\paragraph{Deterministic state machine}
is a state machine that from the same state under the same command will always change state in the same way.

Thanks to this property one may describe the state machine's state by the initial state and consecutive commands. 

\paragraph{Service}
is a program that receives requests -- or commands -- and executes them generating a response.

\paragraph{Deterministic service}
is a service, that will respond from given state and given command always with the same response, and will always change the state to the same state.

\paragraph{Client}
is the program sending requests to the service

\paragraph{Atomic -- or total order -- broadcast}
is a networking primitive providing send-to-all communication for which holds:
\begin{itemize}
 \item a message reaches all targets
 \item each two messages are delivered in the same order at every receiver
\end{itemize}

\paragraph{Failure}
is permanent lack of activity from a program. It may be caused by programming error, lack of electricity etc.

We do not consider byzantine crashes, i.e. a process may not misbehave in any way.

\paragraph{Crash model}
defines how the crashed processes may behave.
\begin{list}{}{ \setlength{\leftmargin}{0.2\textwidth} \setlength{\itemindent}{-0.1\textwidth}}
 \item[\textbf{Crash-Stop}] means that if a process failed, it failed permanently and will never be up again
 \item[\textbf{Crash-Recovery}] assumes that a crashed process may recover (i.e. start working again)
\end{list}

\paragraph{Stable storage}
is the memory that survives crashes. Usually this means that stable storage denotates hard drive.
Sometimes also \textbf{unstable storage} name is used, to name memory that does not survive crashes, like the RAM memory usually used for program data.

However, the writes to the stable storage must be permanent, so if a hard drive is used, the writes must be synchronous.

\begin{TODO}
 Poprawić definicje, sprawdzić poprawność. Jeśli sa, to dodać źródła.
\end{TODO}

\section{Theoretical limitations}

\paragraphNewline{Infeasibility in asynchronous model}

The consensus problem is not solvable in asynchronous system where at least one process may crash and processes communicates by sending messages. This fact has been proved in FLP impossibility proof \cite{FLP}.

Therefore some assumptions concerning time must be made.

\paragraphNewline{Number of messages}

In the best case no algorithm is able to solve consensus in time less than $1n+1$, that is one message with the value and one message not carrying the any dataload.

Our implementation, as described in % TODO: reference needed
, is theoretically able to decide messages in $n+1$ time. Moreover, assuming no network congestion and message loss the average time is equal to the best-case time.

However, with TCP and simple UDP it is not possible to use either multicast or broadcast primitive; this prelongs the real time needed for sending a message, as in the lowest network module \emph{broadcast} is translated to $n$ identical $unicast$ messages.

Please note that no other Paxos implementation uses multicast for reducing communication. Only current implementation using multicast is the RingPaxos\cite{Mar10}, but the ring topology used for further message passing increases the time.


\begin{TODO}
 This problem is related with atomic broadcast. If one can be solved, then the other also can be solved.
\end{TODO}


